Санкт-Петербургский государственный университет
телекоммуникаций
им. проф. М. А. Бонч-Бруевича
Кафедра Защищенных систем связи

Разработка защищенного
программного обеспечения

Лекция №2

Основы объектно-ориентированного
программирования

2

Основные понятия ООП
 Инкапсуляция – ограничение доступа к данным и их объединение
с подпрограммами, обрабатывающими эти данные. Данные
называют полями, а подпрограммы – методами класса. Поля и
методы называют членами класса.
 Наследование – возможность строить на основе первоначального
класса другие классы, добавляя новые поля и методы.
Первоначальный класс называется прародителем или
суперклассом, а новые классы – его потомками или подклассами.
 Полиморфизм – явление, при котором методу с одним и тем же
именем соответствует разный программный код. Метод
исполняется по-разному в зависимости от типа объекта.
3

Объявление класса
спецификатор_доступа class Имя_класса extends Суперкласс
implements Базовые_интерфейсы {
спецификатор_доступа тип имя_поля1;
спецификатор_доступа тип имя_поля2;
/…
спецификатор_доступа Конструктор1(аргументы) {
// тело конструктора1
}
спецификатор_доступа Конструктор2(аргументы) {
// тело конструктора2
}
/…
спецификатор_доступа возвращаемый_тип метод1(аргументы) {
// тело метода1
}
спецификатор_доступа возвращаемый_тип метод2(аргументы) {
// тело метода2
}
/…
}

4

Спецификаторы доступа
 public - член класса, доступен из любого кода.
 protected - член класса, доступен только из данного класса и его
потомков.
 private - член класса, доступен только из данного класса.

5

Конструкторы
Имя конструктора класса должно совпадать с именем
класса. В классе может быть несколько конструкторов,
различающихся принимаемыми аргументами. Конструктор
вызывается при создании объекта класса и предназначен
для его инициализации. Конструктор не возвращает никаких
значений.

6

Пример класса
public class Circle {
public double centerX, centerY;
private double radius;
public Circle() {
centerX = centerY = 0.0;
radius = 1.0;
}
public Circle(double cX, double cY, double r) {
centerX = cX;
centerY = cY;
if(r > 0)
radius = r;
else
radius = 1.0;
}
public void setRadius(double r) {
if(r > 0) radius = r;
}
public double getRadius() {
return radius;
}
}

7

Возникновение дистрибутивов
• Задача получить компьютер с постоянно работающей на нём
системой
Linux
стала
востребованной
и
довольно
распространённой;
• Разработчики в хельсинкском и техасском университетах создают
собственные наборы дискет, с которых скомпилированное ядро и
основные утилиты;
• Первым дистрибутивом в современном понимании, получившим
широкое распространение, стал Slackware, созданный Патриком
Фолькердин.
8

Создание экземпляра класса
// объявление
Имя_класса имя_переменной;
// инициализация
имя_переменной = new Имя_конструктора(аргументы_конструктора);
Пример:
Circle circle1, circle2;
circle1 = new Circle();
circle2 = new Circle(4.0, 5.5, 2.0);
или
Circle circle1 = new Circle();
Circle circle2 = new Circle(4.0, 5.5, 2.0);
9

Создание экземпляра класса
Circle circle1;

Сircle1 = new Circle();

circle1

circle1

null

centerX
centerY
radius

10

Копирование
circle1

centerX
centerY
radius

// Копирование ссылки
circle2 = circle1;

circle1
circle2

centerX
centerY
radius

circle2

null

// Копирование объекта
circle2 = circle1.clone();
circle1

circle2

centerX
centerY
radius

centerX
centerY
radius

11

Сравнение
•

Сравнение ссылок (оператор ==) - истинно, если переменные
ссылаются на один и тот же экземпляр класса.
Пример:
if(circle2 == circle1)
System.out.println(“circle1 и circle2 ссылаются
на один и тот же объект”);
• Сравнение объектов (метод boolean Object.equals(Object obj)) истинно, если переменные ссылаются на равные экземпляры класса.
Пример:
if(circle2.equals(circle1))
System.out.println(“circle1 и circle2 ссылаются
на равные объекты”);

12

Перегрузка методов
Синтаксис Java позволяет создавать в одном классе методы с одинаковыми именами,
различающиеся только принимаемыми аргументами.
Пример:
public class Rectangle {
private double width, height;
public void setSize(int a) {
width = a;
height = a;
}
public void setSize(double a) {
width = a;
height = a;
}
public void setSize(double w, double h) {
width = w;
height = h;
}
}
13

Зарезервированное слово this
Зарезервированное слово this предоставляет доступ к полям,
методам и конструкторам данного класса. Его удобно использовать,
если члены класса оказываются недоступны, из-за наличия в области
видимости других переменных или функций с такими же именами,
или при вызове одного конструктора из другого.

14

Пример:
public class Circle {
public double cX, cY;
private double r = 1.0;
public Circle(double cX, double cY, double r) {
this.cX = cX;
this.cY = cY;
this.setRadius(r);
}
public Circle() {
this(0.0, 0.0, 1.0);
}
public void setRadius(double r) {
if(r > 0) radius = r;
}
public double getRadius() {
return radius;
}
}
15

Наследование
У любого класса в Java может быть только один класс-прародитель. Он
указывается с помощью зарезервированного слова extends после имени
класса. Если класс-прародитель не указан, прародителем считается класс
Object.
Пример:
class Point {
// Тело класса
}
class Circle extends Point {
// Тело класса
}
class Rectangle extends Point {
// Тело класса
}

16

Переопределение методов
Класс-потомок может переопределять методы класса прародителя.
Пример:
class Point {
public double x, y;
public double getSquare() {
return 0;
}
}
class Circle extends Point {
public double r;
public double getSquare() {
return Math.PI * r * r;
}
}
class Rectangle extends Point {
public double width, height;
public double getSquare() {
return width * height;
}
}

17

Зарезервированное слово super
Зарезервированное слово super предоставляет доступ к полям, методам и конструкторам
класса-прародителя.
Пример:
class Point {
public double x, y;
public Point(double x, double y) {
this.x = x;
this.y = y;
}
}
class Circle extends Point {
public double r;
public Circle(double x, double y, double r) {
super(x, y);
this.r = r;
}
public boolean inCircle(double x, double y) {
return ( (super.x – x)*(super.x – x) +
(super.y – y)*(super.y – y) < r*r);
}
18

Использование подклассов и суперклассов
Пример:
Point point1, point2;
Circle circle1 = new Circle(0.0, 5.0, 2.5);
point1 = (Point)circle1;
point2 = new Rectangle(0.0, 0.0, 5.0, 3.0);
circle1.getSquare();
point1.getSquare();
point2.getSquare();

19

Оператор instanceof
Оператор instanceof проверяет принадлежность объекта к какому-либо
классу.
Пример:
Point point1;
Circle circle1, circles[];
// ...
if(point1 instanceof Point)
System.out.println(“point1 – объект класса
Point”);
point1 instanceof Circle; // вернёт false
circle1 instanceof Point; // вернёт true
circle1 instanceof Circle; // вернёт true
circles instanceof Circle; // вернёт false
circles[0] instanceof Circle; // вернёт true
20

Интерфейсы
Интерфейсы в Java предназначены для поддержки возможности
множественного наследования.
Объявление интерфейса:
спецификатор_доступа interface Имя_интерфейса extends
Базовые_интерфейсы {
спецификатор_доступа тип константа1 = значение1;
спецификатор_доступа тип константа2 = значение2;
/…
спецификатор_доступа возвращаемый_тип
заголовок_метода1(аргументы);
спецификатор_доступа возвращаемый_тип
заголовок_метода2(аргументы);
/…
}
21

Использование интерфейсов
class Point {
public double x, y;
}
interface Squareable {
public double getSquare();
}
class Circle extends Point implements Squareable {
public double r;
public double getSquare() {
return Math.PI * r * r;
}
}
class Rectangle extends Point implements Squareable {
public double width, height;
public double getSquare() {
return width * height;
}
}

22

Squareable figures[] = new Squareable[3];
figures[0] = new Circle(0.0, 0.0, 3.0);
figures[1] = new Rectangle(0.0, 0.0, 3.0, 4.5);
figures[2] = new Rectangle(1.5, -0.5, 3.0, 4.5);
for(int i = 0; i < figures.length; i++)
System.out.println(“Площадь фигуры “ + (i+1) +
“ равна “ + figures.getSquare());

23

Исключения
В Java предусмотрен механизм обработки исключений.
Исключением называется ошибка времени выполнения
программы. Исключения в Java реализованы в виде
объектов, описывающих исключительную ситуацию. В
случае возникновения ошибки времени выполнения,
создаются объект-исключение и управление передаётся
соответствующему этому объекту обработчику исключений.

24

Конструкция try
В общем случае для обработки исключений используется следующая
конструкция.
try {

// здесь возможно возникновение исключения
} catch(тип_исключения1 переменная1) {
// обработчик исключения типа тип_исключения1
} catch(тип_исключения2 переменная2) {
// обработчик исключения типа тип_исключения2
}
// …
finally {
// код, который выполняется в любом случае после выполнения блока
try или завершения обработки исключения в блоке catch
}
25

26

Использование конструкции try
try {
int a = 4 / 0; // деление на 0
} catch(ArithmeticException e) {
System.out.println(“Исключение: “ + e);
}

27

Приоритет обработчиков исключений
try {
int a = 4 / 0; // деление на 0
} catch(Exception e) {
System.out.println(“Исключение: “ + e);
} catch(ArithmeticException e) {
// этот блок не выполнится, потому что класс
ArithmeticException является подклассом класса
Exception
System.out.println(“Исключение: “ + e);
} finally {
System.out.println(“Этот блок выполнится в
любом случае после завершения блока try или
обработки исключения”);
}

28

Генерация исключения
Для генерации исключений в Java предназначен оператор throw,
которому передаётся объект исключения. Обычно этот объект
создаётся непосредственно при вызове оператора throw.
Пример:
ArithmeticException e = new
ArithmeticException();
throw e;
или
throw new Exception();
29

Оператор throws
Если внутри функции может быть сгенерировано исключение,
необработанное с помощью конструкции try, после объявления
этой функции должно стоять зарезервированное слово throws и
тип генерируемого исключения.
Пример:
public void someFunction()
throws SomeException {
// ...
throw new SomeException();
// ...
}
30

Факты об обобщенном программировании
• Написание кода, который может быть многократно использован с
объектами многих различных типов.
• До появления Java SE 5.0 обобщенное программирование всегда
реализовывалось посредством наследования и приведения типов.
• Позволяет писать более безопасный код, который легче читается,
чем код, перегруженный переменными Object и приведениями
типов.

31

Объявление обобщенного параметра
спецификатор_доступа class Имя_класса<Имя_первого_типа, Имя_второго_типа >{
спецификатор_доступа <Имя_первого_типа> имя_поля1;
спецификатор_доступа <Имя_второго_типа> имя_поля2;
/…
спецификатор_доступа Конструктор1(аргументы) {
// тело конструктора1
}
/…
спецификатор_доступа в < Имя_первого_типа > метод1(аргументы){
// тело метода1
}
спецификатор_доступа возвращаемый_тип метод2(< Имя_второго_типа >
имя_переменной) {
// тело метода2
}

}
32

Пример кода с обобщенным параметром
public class Pair<T> {
private T first; private T second;
public Pair() { first = null; second = null; }
public Pair(T first, T second) { this.first = first;
this.second = second; }
public T getFirst() { return first; }
public T getSecond() { return second; }
public void setFirst(T newValue) { first = newValue; }
public void setSecond(T newValue) { second = newValue; }
}
33

Создание экземпляра класса
Вы создаете экземпляр обобщенного типа, подставляя имя типа вместо
переменной типа:
Pair <String> pair;
pair= new Pair <String>();
Вы можете воспринимать результат как обычный класс с конструкторами:
Pair <String>();
Pair <String> (String, String);
и методами:
String getFirst();
String getSecond();
void setFirst(String);
void setSecond(String);

34

Обобщенные методы
Метод может быть определен внутри обычного класса, а не внутри
обобщенного.
Пример:
class ArrayAlg{
public static <T> T getMiddle(T[] a){
return a[a.length / 2];
}
}

Вызов обобщенного метода:
String middle = ArrayAlg.<String>getMiddle(names);
35

Ограничения переменных типов
В некоторых случаях класс или метод нуждается в наложении
ограничений на переменные типов.
class ArrayAlg{
public static <T> T min(T[] a) {
if (a == null || a.length == 0)
return null;
T smallest = a[0];
for (int i = 1; i < a.length; i++)
if (smallest.compareTo(a[i]) > 0)
smallest = a[i];
return smallest;
}
}

36

Ограничения переменных типов
class ArrayAlg{
public static <T extends Comparable> T
min(T[] a) {
if (a == null || a.length == 0)
return null;
T smallest = a[0];
for (int i = 1; i < a.length; i++)
if (smallest.compareTo(a[i]) > 0)
smallest = a[i];
return smallest;
}
}

37

Классы-коллекции
• Класс Vector
• Класс Stack
• Класс Hashtable
• Интерфейс Collection
• Интерфейс List
• Интерфейс Set
• Интерфейс Map
38

Интерфейс List
Расширяет интерфейс collection, описывает методы работы с упорядоченными
коллекциями. Иногда их называют последовательностями (sequence). Элементы такой
коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.
List<String> strings = new ArrayList<String>();
strings.add("First");
strings.add("Second");
strings.add("Third");
strings.remove(strings.indexOf("Second"));
for (String string : strings) {
System.out.println(string);
}
39

Основные методы интерфейса List
• void add(E e) – добавляет объект e в конец списка.
• E get(int index) – возвращает объект, находящийся по индексу
index.
• E remove(int index) – удаляет объект, находящийся по индексу
index.
• boolean contains(Object o) – проверяет, содержится ли в списке
объект o.
• int indexOf(Object o) – возвращает индекс, по которому в списке
находится объект o или -1, если такого объекта в списке нет.
40

Интерфейс Map
Описывает коллекцию, состоящую из пар "ключ — значение". У
каждого ключа только одно значение, что соответствует
математическому понятию однозначной функции или
отображения.
Map<String, String> map = new HashMap<String,
String>();
map.put("key1", "value1");
map.put("key2", "value2");
System.out.println(map.get("key1"));

41

Основные методы интерфейса List
• V put(K key, V value) – ставит значение value в соответствие
ключу key.
• V get(K key) – возвращает значение, соответствующее ключу key
или null, если для ключа key не было задано никакого
соответствия.
• V remove(Object key) – удаляет пару ключ-значение для
переданного ключа key.

42

Официальная документация JDK6 http://download.oracle.co
m/javase/6/docs/api/

43

