Санкт-Петербургский государственный университет
телекоммуникаций
им. проф. М. А. Бонч-Бруевича
Кафедра Защищенных систем связи

Разработка защищенного
программного обеспечения

Лекция №1

Введение в Java. Типовые задачи

2

Сравнение языков программирования C++ и Java
Переносимость на уровне исходного Переносимость на уровне байткода. Принцип: Write once compile
кода. Принцип: Write once run
anywhere (WOCA).
anywhere / everywhere (WORA /
WORE).
Разрабатывался для системного
Разрабатывался для прикладного
программирования.
программирования в неоднородных
компьютерных сетях и
программирования бытовых
электронных устройств.
Возможно использование
Полностью объектнопроцедурного и объектноориентированный язык.
ориентированного
программирования.
Явное управление памятью,
Отсутствие указателей, не
поддержка указателей.
допускается прямое обращение к
памяти.
3

Сравнение языков программирования C++ и Java
Отсутствие контроля границ
массивов.
Программа сама управляет
выделением и освобождением
памяти.
Поддержка множественного
наследования.
Отсутствует стандартный механизм
документирования исходного кода.
Поддержка оператора goto.
Нестрогий контроль типов.

Контроль границ массивов.
Автоматическая сборка мусора.

Множественное наследование
реализовано с помощью
интерфейсов.
Документирование с помощью
Javadoc.
Отсутствие оператора goto.
Поддержка меток в циклах.
Строгий контроль типов.

4

Компиляция программ
C++
*.c, *.cpp, *.h
(файлы исходного кода)

*.obj
(объектные файлы)

Исполняемый модуль

*.class

*.jar
(архив Jar)

Java
*.java
(файлы исходного кода)

5

Выполнение программ
C++

Java

Исполняемый модуль
(имеет формат,
поддерживаемый требуемой
операционной системой, и
содержит инструкции требуемой
архитектуры процессора)

Архив Jar или файл *.class
(содержит платформеннонезависимый байт-код)

Операционная система

JVM (Java Virtual Machine) –
Виртуальная машина Java.
(преобразует байт-код в
инструкции целевого процессора
во время выполнения, JiT (Just in
Time) –компиляция)

Операционная система
6

Необходимое программное обеспечение
• JDK (Java Development Kit) – набор инструментов разработки на
языке Java (включён в Mac OS X, для Windows требуется скачать с
сайта http://www.oracle.com/technetwork/java/javase/downloads/in
dex.html)
• Интегрированная среда разработки (IDE, Integrated development
environment).

7

IDE
В настоящее время существует несколько свободно
распространяемых сред разработки на Java:
• NetBeans (http://netbeans.org/)
• Eclipse (http://www.eclipse.org/)
• JDeveloper (http://www.oracle.com/technetwork/develope
r-tools/jdev/overview/index.html)
А также, коммерческие IDE, такие как:
• IntelliJ IDEA (http://www.jetbrains.com/idea/)
• JBuilder (https://github.com/rails/jbuilder/releases)
8

Создание проекта на Java в среде IntelliJ IDEA

9

Создание проекта на Java в среде IntelliJ IDEA

10

Создание проекта на Java в среде IntelliJ IDEA

11

Первая программа
import java.io.*;
public class Main {
public static void main(String[] args) throws IOException {
double a, b, c, d;
BufferedReader in = new BufferedReader(
new InputStreamReader(System.in));
System.out.print("Введите коэффициент a: ");
a = Double.parseDouble(in.readLine());
System.out.print("Введите коэффициент b: ");
b = Double.parseDouble(in.readLine());
System.out.print("Введите коэффициент c: ");
c = Double.parseDouble(in.readLine());
if ((d = b * b - 4 * a * c) < 0) {
d = 0.5 * Math.sqrt(-d) / a;
a = -0.5 * b / a;
System.out.printf("x1 = %.2f - i%.2f\nx2 = %.2f + " +
"i%.2f\n", a, d, a, d);
} else {
d = 0.5 * Math.sqrt(d) / a;
a = -0.5 * b / a;
System.out.printf("x1 = %.2f\nx2 = %.2f\n", a - d, a + d);
}
}
}

12

Первая программа

13

Целочисленные типы данных
Тип

Оболочечны Ширина (в
й класс
битах)

Область допустимых значений

long

Long

64

-9223372036854775808 ..
9223372036854775807

int

Integer

32

-2147483648 .. 2147483647

short

Short

16

-32768 .. 32767

byte

Byte

8

-128 .. 127

14

Операторы для работы с целочисленными данными
Оператор
+
*
/
%
=
++
-+=
-=
*=
/=

Назначение
Сложение
Вычитание
Умножение
Целочисленное деление
Остаток от деления
Присваивание
Инкремент
Декремент
Сложение с присваиванием
Вычитание с присваиванием
Умножение с присваиванием
Целочисленное деление с
присваиванием

Пример
a+b
a-b
a*b
a/b
a%b
a=b
a++, ++a
a--, --a
a+=b
a-=b
a*=b
a/=b

%=

Остаток от деления с
присваиванием

a%=b

15

Вещественные типы
Имя

Оболочечны Ширина (в
й класс
битах)

Область допустимых значений по
модулю

double

Double

64

4.9e-324 .. 1.8e+308

float

Float

32

1.4e-045 .. 3.4e+038

16

Операторы для работы с вещественными типами
Оператор
+
*
/
%
=
++
-+=
-=

Назначение
Сложение
Вычитание
Умножение
Деление
Остаток от деления
Присваивание
Инкремент
Декремент
Сложение с присваиванием
Вычитание с присваиванием

Пример
a+b
a-b
a*b
a/b
a%b
a=b
a++, ++a
a--, --a
a+=b
a-=b

*=

Умножение с присваиванием a*=b

/=
%=

Деление с присваиванием
Остаток от деления с
присваиванием

a/=b
a%=b
17

Символьный тип
Имя

Оболочечный
класс

Ширина (в
битах)

Область допустимых
значений

char

Character

16

\u0000 .. \uFFFF

Примеры символьных констант
Запись
Непосредственно символ
Значение символа в
восьмеричной форме
Значение символа в
шестнадцатеричной форме

Пример
‘a’
‘\141’
‘\u0061’

18

Логический тип
Имя

Оболочечный
класс

Область допустимых значений

boolean

Boolean

true, false

Логические операторы
Оператор
Назначение

Пример

&&

Логическое И

a&&b

||

Логическое ИЛИ

a||b

!

Логическое НЕ

!a

19

Операторы сравнения
Оператор

Назначение

Пример

==

Равно

a==b

!=

Не равно

a!=b

>

Больше

a>b

<

Меньше

a<b

>=

Больше или равно

a>=b

<=

Меньше или равно

a<=b
20

Комментарии
•Однострочный комментарий открывается двумя прямыми слешами //.
Всё, что стоит правее этих символов является комментарием и игнорируется
компилятором.
Пример:
// Это комментарий
•Многострочный комментарий заключается в скобки из символов /* и */.
Всё что находится внутри этих скобок является комментарием и
игнорируется компилятором.
Пример:
/* Это многострочный
Комментарий */
21

Составной оператор
Составной оператор представляет собой несколько операторов,
заключённых в фигурные скобки {}. Этот оператор используется,
если требуется последовательность нескольких операторов в
конструкциях, предусматривающих использование только одного
оператора, например, после оператора if.
Пример:
{
Оператор1;
Оператор2;
}

22

Условный оператор if
if( условие )
оператор1;
else
оператор2;

23

Редуцированная форма оператора if
if( условие )
оператор1;

24

Оператор выбора switch
switch( выражение ) {
case значение1:
операторы;
break;
case значение2:
операторы;
break;
// и т.д.
default:
операторы;
}

25

Оператор цикла for
for( блок инициализации;
условие выполнения
тела цикла;
блок изменения
счётчиков )
оператор;

26

Цикл с предусловием while
while( условие )
оператор;

27

Цикл с постусловием do-while
do
оператор;
while( условие )

28

Операторы прерывания
• continue – прерывание выполнение тела цикла и переход к
следующей итерации.
• break – выход из текущего цикла или оператора switch.
• return – выход из текущей функции. Если функция возвращает
какое-либо значение, после оператора return должно быть указано
это значение.
• System.exit(int n) – выход из программы с кодом завершения n.
Выход считается нормальным, если n равно 0. В противном случае
выход считается аварийным.

29

Консольный ввод-вывод
• System.in – стандартный поток ввода.
• System.out – стандартный поток вывода.
• System.err – стандартный поток вывода сообщений об ошибках.

30

Вывод
• Для вывода информации в потоки System.out и System.err
используются следующие методы:
• print(<аргумент>) – выводит текстовое представление
аргумента в поток вывода.
• println(<аргумент>) – выводит текстовое представление
аргумента в поток вывода и переводит курсор на новую
строку.
• println() – отправляет в поток вывода символ перевода строки.
• printf(…) – функция полностью аналогична функции printf
языка C.
31

Примеры:
System.out.print(2.65);
System.out.println(a);
System.out.println(“текстовая строка”);
System.err.printf(“Ошибка %d\n”, err_num);

32

Ввод
• Для ввода данных с текстовой консоли удобно использовать
вспомогательные классы InputStreamReader и BufferedReader.
Класс BufferedReader буферизует ввод, позволяя вводить
информацию построчно. Если требуется ввести числовые данные,
то для преобразования введённого текста к числовому виду можно
использовать оболочечные классы.

33

Примеры:
// создание экземпляра класса BufferedReader
на основе
// стандартного потока ввода System.in
BufferedReader in = new BufferedReader(new
InputStreamReader(
System.in));
// ввод вещественного значения
double a = Double.parseDouble(in.readLine());
// ввод целочисленного значения
int b = Integer.parseInt(in.readLine());
// ввод строки целиком
String c = in.readLine();
34

Типовые задачи.
Массивы

Массив – группа однотипных переменных,
обращение к которым выполняется по общему
имени. Доступ к элементу массива осуществляется
по его индексу. Java допускает создание массивов
любого типа. Массивы в Java могут иметь одно или
более измерений. Массивы в Java являются
объектным типом данных.
a

a[0]

a[1]

a[2]

a[3]

a[4]

a[5]

a[6]

a[7]

35

Объявление массива
тип имя_переменной[];
или
тип[] имя_переменной;
Пример:
int a[];
double[] vec;

36

Создание массива
имя_переменной = new
тип[количество_элементов];
Пример:
a = new int[12];
vec = new double[4];
При создании массива всем элементам
примитивных типов присваивается значание 0
(false), элементам объектных типов присваивается
значение null.
37

Инициализация массива
имя_переменной[индекс] = значение;
Пример:
a[0] = 14;
for(int i = 0; i < 4; i++)
vec[i] = i*2 + 1;

38

Инициализатор массива
имя_переменной = {элемент1, элемент2, … ,
элементN}
Пример:
a = {1, 2, 3, 4};

39

Операции объявления, создания и инициализации можно объединить.

Пример:
int a[] = new int[10];
double vec[] = {1.0, 0.0, 2.5, -1.3};
boolean flags[] = {true, false, false};

40

Многомерные массивы
В Java многомерные массивы представляют собой массивы
массивов.
Пример:
int a[][] = new int[2][2];
double b[][] = {{1.0, 0.0}, {0.0, 1.0}};
int c[][] = new [3][];
for(int i = 0; i < 3; i++)
c[i] = new int[5];

41

Поля и методы класса массива
 length - Содержит длину массива.
 Object clone() - Копирует массив.
• Пример:
int a[] = new int[10];
System.out.println(“Длина массива: “ +
a.length);
int b[] = a.clone();

42

Класс Arrays
 Arrays.equals(<тип>[] a1, <тип>[] a2) – сравнивает 2
массива. Массивы считаются равными, если содержат
одинаковое количество элементов и элементы с
одинаковыми индексами равны между собой, либо, если
оба массива имеют значение null.
 Arrays.sort(<тип>[] a) – сортирует массив a в порядке
возрастания.
 Arrays.fill(<тип>[] a, <тип> val) – заполняет все элементы
массива значением val.
43

Чтобы использовать класс Arrays, необходимо импортировать его из пакета java.util.

• import java.util.Arrays;
• Пример:
int a[] = {3, 3, 3, 3};
int b[] = new int[4];
Arrays.fill(b, 3);
if(Arrays.equals(a, b))
System.out.println(“Массивы равны”);

44

Вывод массивов
Пример вывода двумерного массива a.
for(int i = 0; i < a.length; i++) {
for(int j = 0; j < a[i].length; j++)
System.out.print(a[i][j] + “ “);
System.out.println();
}

45

Строки
Конструктор
String()

Пример
Результат
String s = new
“”
String();
String(char chars[]) char chars[] = {‘a’, “abc”
‘b’, ‘c’};
String s = new
String(chars);
String(char chars[], char chars[] = {‘a’, “cde”
int startIndex, int ‘b’, ‘c’, ‘d’, ‘e’,
numChars)
‘f’};
String s = new
String(chars, 2, 3);
String(String
stringObj)
Создание из строкового
литерала

String s = new
String(“str”);
String s = “str”;

“str”
“str”
46

Методы класса String
int length()

Возвращает длину строки

char charAt(int where)

Возвращает символ с индексом
where
Возвращает массив символов,
воходящих в строку

char[] toCharArray()

boolean equals(Object str)

Сравнение с другой строкой

boolean equalsIgnoreCase(Object str)

Сравнение с другой строкой без учёта
регистра символов

int indexOf(String str)

Возвращает индекс первого
вхождения подстроки str в строку или
-1, если подстрока ни разу не
встретилась
47

String replace(char oldChar,
char newChar)

Возвращает строку, в которой
символ oldChar заменён на newChar

String concat(String str)

Возвращает строку, полученную
добавлением строки str в конец
строки, для которой вызван метод

String toLowerCase()

Возвращает строку, в которой все
символы приведены к нижнему
регистру
Возвращает строку, в которой все
символы приведены к верхнему
регистру

String toUpperCase()

48

Примеры
String str = "This is a string";
System.out.println("Длина строки: " +
str.length());
System.out.println("Символ с индексом 12: " +
str.charAt(12));
System.out.println("Слово string начинается с
индекса: " + str.indexOf("string"));
if(str.equalsIgnoreCase("this IS a String"))
System.out.println("Строки равны без учёта
регистра");
str = str.replace(' ', '.');
System.out.println("В этой строке пробелы
заменены на точки: ".concat(str));
49

Класс Math
Константы:
Math.E
Math.PI

Число e (2,72…)
Число π (3.14…)

Пример:
System.out.println(“Число e равно: “ +
Math.E);

50

Тригонометрические функции
double Math.sin(double arg)

Синус угла arg, переданного в радианах

double Math.cos(double arg)

Косинус угла arg, переданного в радианах

double Math.tan(double arg)

Тангенс угла arg, переданного в радианах

double Math.asin(double arg) Возвращает угол, синус которого равен arg
double Math.acos(double arg) Возвращает угол, косинус которого равен arg
double Math.atan(double arg) Возвращает угол, тангенс которого равен arg
double Math.atan2(double x,
double y)

Возвращает угол, тангенс которого равен x/y
51

Экспоненциальные функции
double Math.exp(double arg)

Экспонента arg

double Math.log(double arg)

Натуральный логарифм от arg

double Math.log10(double arg) Логарифм по основанию 10 от
arg
double Math.pow(double y,
double x)

y в степени x

double Math.sqrt(double arg)

Квадратный корень arg

52

Прочие функции
<тип> Math.abs(<тип> arg)

Абсолютное значение arg

double Math.ceil(double arg)

Наименьшее целое число, большее
arg
Наибольшее целое число, меньше
или равное arg

double Math.floor(double arg)

<тип> Math.max(<тип> x, <тип> y)

Возвращает большее из чисел x и y

<тип> Math.min( <тип> x, <тип> y)

Возвращает меньшее из чисел x и y

double Math.random()
double Math.toDegrees(double arg)

Возвращает псевдослучайное число
от 0 до 1
Преобразует радианы в градусы

double Math.toRadians(double arg)

Преобразует градусы в радианы
53

Генератор псевдослучайных чисел
Для генерации псевдослучайных чисел в Java предназначен
класс Random. Этот класс находится в пакете java.utils. Чтобы
использовать методы класса Random, его необходимо
создать.
Пример:
import java.util.Random;
// ... где-то в коде
Random r = new Random();
54

Равномерное распределение
Для генерации псевдослучайных чисел равномерного
распределения предназначены следующие методы:
• nextBoolean() – генерирует значение в диапазоне (false, true)
• nextDouble(), nextFloat() – генерируют значение в диапазоне
0.0 .. 1.0
• nextInt(), nextLong() – генерирует целое число из области
значений целого типа
• nextInt(int n) – генерирует целое число в диапазоне 0 .. n-1
Пример:
int a[] = new int[10];
Random r = new Random();
for(int i = 0; i < a.length; i++)
a[i] = r.nextInt(25);
55

Стандартное нормальное распределение
Для генерации псевдослучайных чисел стандартного
нормального распределения предназначен метод
nextGaussian(). Он возвращает псевдослучайное число типа
double, подчинённое закону нормального распределения с
математическим ожиданием 0.0 и стандартным отклонением
1.0.
Пример:
double a[] = new double[128];
Random r = new Random();
for(int i = 0; i < a.length; i++)
a[i] = r. nextGaussian();
56

Ссылки на материалы
• Официальная документация JDK6
http://download.oracle.com/javase/6/docs/api/

57

