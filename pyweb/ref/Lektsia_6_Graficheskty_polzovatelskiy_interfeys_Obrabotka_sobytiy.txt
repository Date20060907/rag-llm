Санкт-Петербургский государственный университет
телекоммуникаций
им. проф. М. А. Бонч-Бруевича
Кафедра Защищенных систем связи

Разработка защищенного
программного обеспечения

Лекция №4

Графический пользовательский
интерфейс. Обработка событий

2

Библиотеки для создания графического интерфейса
 AWT (Abstract Window Toolkit) – Платформенно-зависимый
графический интерфейс.
 Swing – Платформенно-независимый графический
интерфейс.
Все классы библиотеки Swing расположены в пакете
javax.swing.
Библиотека Swing является надстройкой над библиотекой
AWT и предоставляет возможность создания платформеннонезависимого пользовательского интерфейса.

3

Анонимные вложенные классы
• В библиотеках AWT и Swing активно используются
анонимные вложенные классы.
• Эти классы не имеют имени и могут определяться
внутри других классов и выражений.
• Анонимный вложенный класс может быть создан
на основе класса-прародителя или реализовывать
интерфейс.
4

Анонимные вложенные классы
• public class Example {
• public static void main(String args[]) {
•
// Обычный экземпляр объекта Object
•
System.out.println(new Object());
•
// Экземпляр анонимного класса,
•
// унаследованного от Object
•
Object o = new Object() {
•
public String toString() {
•
return "Анонимный класс #1";
•
}
•
};
•
System.out.println(o);
• …

5

Анонимные вложенные классы
• …
• // Экземпляр анонимного класса,
•
// унаследованного от Object,
•
// созданный внутри выражения
•
System.out.println(new Object() {
•
public String toString() {
•
return "Анонимный класс #2";
•
}
•
});
• }
• }
6

Потоки. Класс Thread.
• Когда запускается любое приложение, то начинает
выполняться поток, называемый главным потоком (main).
• От него порождаются дочерние потоки.
• Главный поток, как правило, является последним потоком,
завершающим выполнение программы.

7

Потоки. Класс Thread.
• public class MyThread extends Thread {
•
public void run() {
•
System.out.print("My Thread!");
•
}
• }
• …
• public void onClick(View view) {
•
MyThread myThread = new MyThread();
•
myThread.start();
• }
• …
8

Интерфейс Runnable
• Интерфейс Runnable предназначен для реализации потоков
выполнения в Java.
• Он содержит единственный метод void run(), который
вызывается при запуске потока.

• public interface Runnable {
•
public void run();
• }
9

Интерфейс Runnable
• class NewThread implements Runnable {
•
public void run() {
•
try {
•
for(int i = 5; i > 0; i--) {
•
System.out.println("Дочерний поток: " + i);
•
Thread.sleep(500);
•
}
•
} catch (InterruptedException e) {
•
System.out.println("Дочерний поток прерван.");
•
}
•
System.out.println("Дочерний поток завершен.");
•
}
• }
• …
10

Интерфейс Runnable
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•

…
class ThreadDemo {
public static void main(String args[]) {
new NewThread();
try {
for(int i = 5; i > 0; i--) {
System.out.println("Главный поток: " + i);
Thread.sleep(1000);
}
} catch (InterruptedException e) {
System.out.println("Главный поток прерван.");
}
System.out.println("Главный поток завершен.");
}
}

11

Использование библиотеки Swing
• Все действия с библиотекой Swing должны выполняться в
потоке выполнения обработки событий (Event Dispatch
Thread).
• Для добавления своего кода в поток обработки событий
предназначен статический метод
EventQueue.invokeLater(Runnable), принимающий в
качестве аргумента экземпляр класса, реализующего
интерфейс Runnable.
12

Использование библиотеки Swing
import java.awt.*;
import javax.swing.*;
public class Example {
public static void main(String args[]) {
EventQueue.invokeLater(new Runnable() {
public void run() {
// Использование библиотеки Swing
}
});
}
}

13

Класс JFrame
• Класс JFrame представляет собой окно верхнего уровня,
имеющее заголовок, рамку, кнопки закрытия,
сворачивания и распахивания.

14

Конструктор класса JFrame
Конструктор

Пример

Описание

JFrame()

JFrame frame = new JFrame();

Конструктор по умолчанию,
создаёт пустое окно.

JFrame(String title)

JFrame frame = new
JFrame(“Заголовок”);

Создаёт пустое окно с
заголовком title.

15

Некоторые методы класса JFrame
Метод

Описание

int getDefaultCloseOperation()
void setDefaultCloseOperation(int operation)

Получить или установить действие,
производимое, когда пользователь нажимает
кнопку закрытия окна.

void setLayout(LayoutManager manager)

Установить менеджер компоновки окна.

16

Некоторые методы класса Component
Метод
void addKeyListener(KeyListener l)

Описание
Добавляет новый обработчик событий
клавиатуры.

void addMouseListener(MouseListener l)

Добавляет новый обработчик событий нажатия
кнопок мыши.

void addMouseMotionListener
(MouseMotionListener l)

Добавляет новый обработчик событий
перемещения указателя мыши.

Color getBackground()
void setBackground(Color c)

Возвращает или устанавливает цвет фона.

Color getForeground()
void setForeground(Color c)

Возвращает или устанавливает цвет переднего
плана.

int getHeight()
int getWidth()

Возвращает высоту.
Возвращает ширину.
17

Некоторые методы класса Component
Метод

Описание

int getX()

Возвращает координату x.

int getY()

Возвращает координату y.

void repaint()

Перерисовывает окно.

void repaint(int x, int y, int width, int height)

Перерисовывает участок окна.

void setBounds(int x, int y, int width, int height)

Изменяет размер или перемещает окно, путём
установки новых границ.

void setSize(int width, int height)

Устанавливает ширину и высоту.

void setVisible(boolean b)

Показывает или скрывает окно.
18

Некоторые методы класса Container
Метод

Описание

Component add(Component comp)

Добавляет компонент к контейнеру

Component findComponentAt(int x, int y)

Возвращает компонент, находящийся в
заданной точке

Insets getInsets()

Возвращает отступы контейнера

void remove(Component comp)

Удаляет компонент из контейнера

void removeAll()

Удаляет все компоненты из контейнера

19

Пример окна JFrame
import java.awt.*;
import javax.swing.*;
public class Window {
public static void main(String args[]) {
EventQueue.invokeLater(new Runnable() {
public void run() {
JFrame frame =
new JFrame("Пример окна верхнего уровня");
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
frame.setSize(300, 200);
frame.setVisible(true);
}
});
}
}
20

Пример окна JFrame
public class ForegroundWindow extends JFrame {
public ForegroundWindow() {
super("Пример окна верхнего уровня");
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
setSize(300, 200);
setVisible(true);
}
public static void main(String[] args) {
EventQueue.invokeLater(new Runnable() {
public void run() {
new ForegroundWindow().setVisible(true);
}
});
}
}
21

Пример окна JFrame

22

Особенности рисования в классах Component и JComponent

23

Особенности рисования в классах Component и JComponent

24

Особенности рисования в классах Component и JComponent

• Так как класс JFrame содержит в своей иерархии
класс Component, его прорисовка должна
происходить в методе paint.
• Другие классы Swing, унаследованные от
JComponent должны выполнять прорисовку в
методе paintComponent.

25

Пример подхода к рисованию класса Component
• import java.awt.*;
• import javax.swing.*;
• public class ForegroundWindow extends JFrame {
• public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
•
setSize(300, 200);
•
setVisible(true);
• }
• …
26

Пример подхода к рисованию класса Component
• …
• public void paint(Graphics g) {
•
// прорисовка компонента
•
super.paint(g);
•
g.drawRect(50, 50, 200, 100);
•
}
•
public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
•
}
• }

27

Пример подхода к рисованию класса JComponent
• import java.awt.*;
• import javax.swing.*;
• public class ForegroundWindow extends JFrame {
•
public class DrawingPanel extends JPanel {
•
protected void paintComponent(Graphics g) {
•
super.paintComponent(g);
•
g.drawRect(50, 50, 200, 100);
•
}
•
}
•
public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
• …

28

Пример подхода к рисованию класса JComponent
• …
• setSize(300, 200);
•
add(new DrawingPanel());
•
setVisible(true);
•
}
•
public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
•
}
• }
29

Вычисление области рисования
• Компонент JComponent может содержать рамку, поэтому при
рисовании необходимо вычислить размеры отступов, которые
занимает эта рамка.
• Эти размеры могут быть получены с помощью функции
getInsets(), которая возвращает объект класса Insets.
• Класс Insets содержит в себе поля left, right, top, bottom,
которые определяют отступы слева, справа, сверху и снизу.
30

Вычисление области рисования
•
•
•
•
•
•
•
•
•
•
•
•
•
•

import java.awt.*;
import javax.swing.*;
public class ForegroundWindow extends JFrame {
public class DrawingPanel extends JPanel {
protected void paintComponent(Graphics g) {
super.paintComponent(g);
Insets is = getInsets();
g.drawLine(is.left, is.top, getWidth() - is.right,
getHeight() - is.bottom);
g.drawLine(is.left, getHeight() - is.bottom,
getWidth() - is.right, is.top);
}
}
…
31

Вычисление области рисования
• …
•
public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
•
setSize(300, 200);
•
DrawingPanel dp = new DrawingPanel();
•
dp.setBorder(BorderFactory.createTitledBorder(
•
"Заголовок рамки"));
•
add(dp);
•
setVisible(true);
•
}
• …
32

Вычисление области рисования
• …
• public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
• }
• }
33

Вычисление области рисования

34

Класс Graphics
•
•
•
•
•
•
•
•
•
•
•
•
•
•

import java.awt.*;
import javax.swing.*;
public class ForegroundWindow extends JFrame {
public class DrawingPanel extends JPanel {
protected void paintComponent(Graphics g) {
super.paintComponent(g);
g.drawLine(20, 20, 100, 100);
g.drawOval(50, 30, 100, 150);
g.drawRect(90, 80, 150, 100);
g.drawRoundRect(130, 30, 80, 160, 20, 40);
g.drawString("Строка", 100, 100);
}
}
…
35

Класс Graphics
• …
•
public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
•
setSize(300, 250);
•
add(new DrawingPanel());
•
setVisible(true);
•
}
•
public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
•
}
• }

36

Класс Graphics

37

Класс Graphics
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•

import java.awt.*;
import javax.swing.*;
public class ForegroundWindow extends JFrame {
public class DrawingPanel extends JPanel {
protected void paintComponent(Graphics g) {
super.paintComponent(g);
g.setColor(Color.GREEN);
g.fillOval(50, 30, 100, 150);
g.setColor(Color.BLUE);
g.fillRect(90, 80, 150, 100);
g.setColor(Color.RED);
g.fillRoundRect(130, 30, 80, 160, 20, 40);
}
}
…

38

Класс Graphics
• …
• public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
•
setSize(300, 250);
•
add(new DrawingPanel());
•
setVisible(true);
•
}
•
public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
•
}
• }
39

Класс Graphics

40

Класс Graphics
• public class ForegroundWindow extends JFrame {
•
public class DrawingPanel extends JPanel {
•
protected void paintComponent(Graphics g) {
•
super.paintComponent(g);
•
int xPoints[] = new int[50];
•
int yPoints[] = new int[50];
•
for(int i = 0; i < 50; i++) {
•
xPoints[i] = i * 6;
•
yPoints[i] =
•
(int)(80*Math.sin(i * Math.PI / 12)) + 150;
•
}
•
g.drawPolyline(xPoints, yPoints, 50);
•
}
•
}
• …

41

Класс Graphics
• …
•
public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
•
setSize(300, 300);
•
add(new DrawingPanel());
•
setVisible(true);
•
}
•
public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
•
}
• }
42

Класс Graphics

43

Класс Color
• import java.awt.*;
• import javax.swing.*;
• public class ForegroundWindow extends JFrame {
•
public class DrawingPanel extends JPanel {
•
protected void paintComponent(Graphics g) {
•
super.paintComponent(g);
•
for(int i = 0; i < 256; i += 16)
•
for(int j = 0; j < 256; j+= 16) {
•
g.setColor(new Color(j, 128, i));
•
g.fillRect(i, j, 16, 16);
•
}
•
}
•
}
• …

44

Класс Color
• …
•
public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
•
setSize(300, 300);
•
add(new DrawingPanel());
•
setVisible(true);
•
}
•
public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
•
}
• }
45

Класс Color

46

Класс Font
• import java.awt.*;
• import javax.swing.*;
• public class ForegroundWindow extends JFrame {
•
public class DrawingPanel extends JPanel {
•
protected void paintComponent(Graphics g) {
•
super.paintComponent(g);
•
g.setFont(new Font("Times New Roman", Font.BOLD, 12));
•
g.drawString("Times New Roman", 20, 50);
•
g.setFont(new Font("Courier New", Font.ITALIC, 16));
•
g.drawString("Courier New", 20, 100);
•
g.setFont(new Font("Arial Black", Font.ITALIC, 10));
•
g.drawString("Arial Black", 20, 150);
•
g.setFont(new Font("Tahoma", Font.PLAIN, 20));
• …

47

Класс Font
• …
•
g.drawString("Tahoma", 20, 200);
•
g.setFont(new Font("Sans Serif",
•
Font.ITALIC & Font.BOLD, 14));
•
g.drawString("Sans Serif", 20, 250);
•
}
•
}
•
public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
•
setSize(300, 300);
•
add(new DrawingPanel());
•
setVisible(true);
•
}
• …

48

Класс Font
• …
• public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
• }
• }
49

Класс Font

50

Класс JScrollPane
• import java.awt.*;
• import javax.swing.*;
• public class ForegroundWindow extends JFrame {
•
public class DrawingPanel extends JPanel {
•
public DrawingPanel() {
•
setPreferredSize(new Dimension(400, 400));
•
}
•
protected void paintComponent(Graphics g) {
•
super.paintComponent(g);
•
for(int i = 1; i < 10; i++)
•
for(int j = 1; j < 10; j++) {
•
g.drawString(String.valueOf(i*j), i*40, j*40);
•
}
•
}
•
}

51

Класс JScrollPane
• public ForegroundWindow() {
•
super("Пример окна верхнего уровня");
•
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
•
setSize(300, 300);
•
add(new JScrollPane(new DrawingPanel()));
•
setVisible(true);
•
}
•
public static void main(String[] args) {
•
EventQueue.invokeLater(new Runnable() {
•
public void run() {
•
new ForegroundWindow().setVisible(true);
•
}
•
});
•
}
• }

52

Класс JScrollPane

53

Обработка событий

54

Архитектура событий Java
• Архитектура, управляемая событиями, состоит из четырёх
логических слоев.
Генератор событий
Канал событий
Механизм обработки
событий
Последующее
действие
55

Генератор событий
• Регистрирует факт и представляет этот факт событием.
• Преобразование различных данных, полученных от
датчиков, в единую стандартизированную форму данных,
которые могут быть оценены.
• Событие является строго декларативным.

56

Канал событий
• Канал событий — это механизм, по которому передается
информация от генератора событий к обрабатывающему
события механизму или стоку.
• В одно и тоже время может быть открыто несколько
каналов событий.
• События сохраняются в очереди, ожидая последующей
обработки механизмом обработки событий.
57

Механизм обработки событий
• Механизм обработки событий является местом, где
событие идентифицируется и выбирается
соответствующая реакция на него, которая затем
выполняется.

58

Механизм обработки событий
• Реализация последствия события. Оно может проявляться
различными способами и формами.
• В зависимости от предоставляемого стоком (механизмом
обработки событий) уровня автоматизации действия
могут не потребоваться.

59

Классификация событий
• Низкоуровневые события
– Создаются системой на основе действий пользователя
– Инициатор события – текущая компонента

• Высокоуровневые события
– Создаются компонентами на основе других событий
– Инициатор события – компонента создавшая событие

60

Обработка событий
Низкоуровневые события
EventThread
User Input

XXXEvent

Event Queue

XXXEvent

XXXListener

Высокоуровневые события
EventThread
XXXEventSource

fireXXX

XXXListener

61

Низкоуровневые события
• Ввод пользователя
– InputEvent – базовый класс
– KeyEvent – событие клавиатуры
– MouseEvent – событие мыши
– MouseWheelEvent – событие колеса прокрутки

• Изменение состояния компоненты
– ComponentEvent – изменение видимости / размера /
местоположения компонента
– FocusEvent – изменение фокуса
– ContainerEvent – добавление / удаление компонент
– WindowEvent – операции с окнами
62

Высокоуровневые события
• Примеры
– ActionEvent – нажатие на кнопку
– MenuEvent – операции с меню
– PopupMenuEvent – операции с всплывающим меню
– и др.

63

Подтипы событий
• Событие может иметь несколько подтипов, для которых у
слушателя вызываются разные методы
• Пример
– Событие KeyEvent
– Класс KeyListener
• Метод keyTyped(KeyEvent)
• Метод keyPressed(KeyEvent)
• Метод keyReleased(KeyEvent)

64

Создание слушателей
•

Реализация слушателя
1. Реализовать интерфейс
2. Добавить слушателя к компоненту
3. Реагировать на события

•

Вспомогательные классы
– XXXAdapter – для реализации слушателей с несколькими
методами

65

Пример слушателя
public class F1EventListener
extends KeyAdapter implements KeyListener {
public void keyTyped(KeyEvent e) {
if (e.getKeyCode() == KeyEvent.VK_F1 &&
e.getModifiers() == 0) {
// Нажата клавиша F1
}
}
}
66

События клавиатуры
Для обработки событий клавиатур предназначен
интерфейс KeyListener.
public void keyTyped(KeyEvent e);

Введён текстовый символ.

public void keyPressed(KeyEvent e);

Клавиша нажата.

public void keyReleased(KeyEvent e); Клавиша отпущена.

67

События клавиатуры
• В качестве события используется класс KeyEvent.
• Слушатель событий клавиатуры регистрируется с
помощью метода public void addKeyListener(KeyListener l).
• Для обработки событий клавиатуры необходимо
реализовать интерфейс KeyListener или создать класснаследник класса KeyAdapter.
• Класс KeyAdapter является пустым классом, реализующим
интерфейс KeyListener.

68

Пример
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class KeyEventExample extends JFrame implements KeyListener {
public KeyEventExample() {
setSize(400, 300);
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
addKeyListener(this);
}
public void keyTyped(KeyEvent e) {
}
public void keyPressed(KeyEvent e) {
}
public void keyReleased(KeyEvent e) {
}
}
69

Пример
public class KeyEventExample extends JFrame {
class MyKeyAdapter extends KeyAdapter {
public void keyPressed(KeyEvent e) {
}
}
public KeyEventExample() {
setSize(400, 300);
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
addKeyListener(new MyKeyAdapter());
}
}

70

Типы кнопок

71

Нажатие на кнопку
• Событие ActionEvent
– Свойства
• getActionCommand() – название команды
• getModifiers() – состояние клавиш-модификаторов
• getWhen() – когда произошло

• Слушатель ActionListener
– Метод actionPerformed(ActionEvent e)

72

Базовый класс для кнопок
• Класс AbstractButton
• Конструкторы
– AbstractButton() – конструктор по умолчанию

• Методы
– doClick() – нажать на кнопку
– isSelected() – состояние кнопки

73

Базовый класс кнопок
• Свойства
– action – ассоциированное действие
– actionCommand – название команды
– label – надпись на кнопке
– enabled – разрешено ли нажимать
– icon, disabledIcon, pressedIcon – иконки
– horizontal(vertical)Alignment – выравнивание текста и иконки
– horizontal(vertical)TextPosition – положение текста относительно
иконки
– margin -- отступы
74

Обыкновенные кнопки
• Класс JButton
• Конструкторы
– JButton(text?, icon?)

• Методы
– JRootPane.setDefaultButton(JButton) – устанавливает кнопку по
умолчанию

75

Кнопки с флажком
• Класс JCheckBox
• Конструкторы
– JCheckBox(text?, icon?, selected?)

76

Кнопки-переключатели
• Класс JRadioButton
• Конструкторы
– JCheckBox(text?, icon?, selected?)

77

Действия
• Действие – абстракция действия которое можно
произвести
• Интерфейс Action
• Методы
– actionPerformed(ActionEvent) – совершить действие
– setEnabled(boolean) – запретить / разрешить
– isEnabled() – проверить разрешение
– putValue(key, value) – записать значение свойства
– getValue(key) – прочитать значение свойства

78

Свойства действий
• Константы интерфейса Action
– NAME – название действия
– SHORT_DESCRIPTION –описание для всплывающих подсказок
– LONG_DESCRIPTION –описание для контекстной помощи
– ACTION_COMMAND_KEY – имя команды
– SMALL_ICON – иконка

79

Пример действия
• Открытие директории для просмотра
public class OpenAction extends AbstractAction {
public OpenAction() {
super("Open");
putValue(SHORT_DESCRIPTION, "Open a directory");
putValue(SMALL_ICON, loadIcon("load16.gif"));
}
public void actionPerformed(ActionEvent e) {
// Open directory
}
}
80

Пример действия
• Открытие директории для просмотра
public class OpenAction extends AbstractAction {
public OpenAction() {
super("Open");
putValue(SHORT_DESCRIPTION, "Open a directory");
putValue(SMALL_ICON, loadIcon("load16.gif"));
}
public void actionPerformed(ActionEvent e) {
// Open directory
}
}
81

