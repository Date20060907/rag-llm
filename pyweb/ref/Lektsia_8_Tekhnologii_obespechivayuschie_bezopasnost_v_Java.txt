Санкт-Петербургский государственный университет
телекоммуникаций
им. проф. М. А. Бонч-Бруевича
Кафедра Защищенных систем связи

Разработка защищенного
программного обеспечения

Лекция №8

Технологии обеспечивающие
безопасность в Java.

Механизмы безопасности в Java
 Структурные функциональные возможности языка.
 Средства контроля доступа, определяющие действия,
которые разрешается или запрещается выполнять в коде.
 Механизм цифровой подписи, предоставляющий авторам
возможность аутентификации выполняемого кода.

Механизмы безопасности в Java
 Загрузчики классов, проверяющие файлы на предмет
целостности при их загрузке.
 Диспетчер защиты, определяющий действия которые
разрешено или запрещено выполнять в коде.
 Библиотека java.security, содержащая основные
алгоритмы шифрования и позволяющая подписывать
код.

Исполнение программы Java
Загрузка класса по его идентификатору загрузчиком
классов (ClassLoader).
Верификация - проверка того, что структура класса
верна (инструкции имеют корректные коды, методы
имеют сигнатуры).
Подготовка - присваивание значений по умолчанию
статическим полям класса.
Разрешение - все ссылки проверяются (заменяются
на прямые ссылки).
Инициализация - выполнение статического
инициализирующего блока и присваивание значений
статическим полям.

Алгоритм запуска
• Допустим выполнение программы начинается с файла
MyProgram.class.
 Механизм загрузки файлов классов, загружает его в память
путем считывания с диски или скачивая из Интернета.
 Если в классе MyProgram встречаются поля или объекты,
ссылающиеся на классы других типов, то дополнительно
загружаются файлы этих классов.
 Выполнение метода main() из класса MyProgram.
 Если для выполнения метода main() требуются другие классы,
то они загружаются из соответствующих файлов.

Основные загрузчики
• Существуют три основных загрузчика классов.
Загрузчик базовых классов.
Загрузчик расширений классов.
Загрузчик системных классов.

Базовый загрузчик
Является частью виртуальной машины.
Загружает базовые или системные классы из файлов rt.jar
и i18n.jar
Реализован на языке С.
К нему не соответствует ни один из объектов типа
ClassLoader.

Загрузчик расширений
Загружает стандартные расширения из каталога
<JAVA_HOME>/lib/ext.
Загрузчик расширений представляет собой экземпляр
класса URLClassLoader.

Системный загрузчик
Загружает системные и прикладные, которые
размещаются в каталогах, указанных в переменой
CLASSPATH.
Загрузчик системных классов представляет собой
экземпляр класса URLClassLoader..

Иерархия загрузчиков
Загрузчик базовых
классов

rt.jar

Загрузчик
расширений классов

jre/lib/ext

Загрузчик системных
классов

CLASSPATH

Загрузчик
пользовательских
классов

user.jar

Пример ситуации переопределения загрузчика
Рассмотрим следующий пример:
В коде прикладной программы имеется метод,
вызывающий метод Class.forName(classNameString).
Этот метод вызывается из класса подключаемого
модуля.
Параметр classNameString указывает на класс,
содержащийся в архивном файле user.jar.

Пример извлечения и установки загрузчика
Установка любого загрузчика:
Thread t = Thread.currentThread();
t.setContextClassLoader(loader);
Извлечение метода вызывая другой загрузчик:
Thread t = Thread.currentThread();
ClassLoader loader =
t.getContextClassLoader();
Class cl = loader.loadClass(className);

Основные методы загрузчика

Основные методы загрузчика

Создание собственного загрузчика
Объявить свой класс унаследовав от класса ClassLoader.
Переопределить метод findClass(String className).
Вызвать метод defineClass() из суперкласса.

Пример создания загрузчика
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•

package classLoader;
import j ava.io.*;
import java.lang.reflect.*;
import java.nio.file.*;
import j ava.awt.*;
import j ava.awt.event.*;
import javax.swing.*;
public class ClassLoaderTest

I

{
public static void main(String[] args)
{
EventQueue.invokeLater(new Runnable()
{
public void run()
{
JFrame frame = new ClassLoaderFrame(); frame.setTitle("ClassLoaderTest");
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
frame.setVisible(true);
}
});

Пример создания загрузчика
/* Окно которое содержит два текстовых поля ввода имени загружаемого
и ключ расшифровки
*/
class ClassLoaderFrame extends JFrame
{
private JTextField keyField = new JTextField("3", 4);
private JTextField nameField = new JTextField("Calculator", 30);
private static final int DEFAULT_WIDTH = 300;
private static final int DEFAULT_HEIGHT = 200;

public ClassLoaderFrame()
{
setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT); setLayout(new GridBagLayout());
add(new JLabel("Class"), new GBC(0, 0).setAnchor(GBC.EAST));
add(nameField, new GBC(1, 0j.setWeight(100, 0).setAnchor(GBC.WEST));
add(new JLabel("Key"), new GBC(0, 1).setAnchor(GBC.EAST));

Пример создания загрузчика
/* Выполняет основной метод указанного класса*/

public void runClass(String name, String key)
{
try
{
ClassLoader loader = new CryptoClassLoader(Integer.parselnt(key));
Class<?> с = loader.loadClass(name);
Method m = c.getMethod("main", String[].class);
m.invoke(null, (Object) new

String[] {});

Пример создания загрузчика
/* Этот загрузчик классов загружает их из зашифрованных файлов */

class CryptoClassLoader extends ClassLoader
{
private int key;

public CryptoClassLoader(int k)
{
key = k;
}
protected Class<?> findClass(String name) throws ClassNotFoundException
{
try
{
byte[] classBytes = null;
classBytes = loadClassBytes(name);

Пример создания загрузчика

/* Загружает и расшифровает байты из файла класса*/

private byte[] loadClassBytes(String name) throws IOException
{
String cname = name.replace(1.', 1/1) + ".caesar";
byte[] bytes =

Files.readAHBytes (Paths.get (cname));

for (int i = 0; i < bytes.length; i++)
bytes[i] = (byte) (bytes[i] - key);
return bytes;
}

Пример создания загрузчика
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•

package classLoader;
import java.io.*;
public class Caesar
{
public static void main(String[] args) throws Exception
{
if (args.length != 3)
{
System.out.println("USAGE: java classLoader.Caesar in out key");
return;
}
try(FilelnputStream in = new FileInputStream(args[0]);
FileOutputStream out = new FileOutputStream(args[1]))
{
int key = Integer.parselnt(args[2]); int ch;
while ((ch = in.readO) != -1)

Верификация байт-кода
Когда загрузчик классов представляет виртуальной машине байт-код
класса, этот код сначала обследуется верификатором. Верификатор
проверяет все классы за исключением системных и определяет те команды,
которые могут нанести ущерб виртуальной машине.
Некоторое виды проверок, выполняемые верификатором:
•
•
•
•
•

Инициализация переменных перед их использованием
Согласование типов ссылок при вызове метода
Соблюдение правил доступа к закрытым данным и методам
Доступ к локальным переменным в стеке во время выполнения
Отсутствие переполнения стека
При невыполнении какой-нибудь из этих проверок класс считается
поврежденным и загружаться не будет.

Верификация байт-кода
Невыполнение какой-либо из этих проверок:
•

Подделка указателей (например, получение указателя как
результат выполнения арифметической операции);
•
Вызов методов объектов с недопустимым набором
параметров;
• Недопустимое преобразование типов;
•
Вызов операции Java-машины с недопустимым набором
параметров;
•
Некорректная операция с регистрами Java-машины
(например, запись регистра с неопределенным содержимым);
Также влечет отказ в загрузке класса, а сам класс считается
поврежденным.

Верификация байт-кода
Java байт-код "проверяется", прежде чем он сможет заработать. Эта схема
проверки предназначена для того, чтобы байт-код, который может был, а
может и не был создан с помощью компилятора Java, играл по правилам. В
конце концов, байт-код возможно был создан во "враждебном"
компиляторе, чей байт-код, предназначенный для сбоя виртуальной
машины Java.
Верификатор проверяет байт-код на различных уровнях.
Простейший тест гарантирует, что формат фрагмента байт-кода
правильный. Более глубоком уровне, встроенные доказательства теорем
применяются к каждому фрагменту. Теорема помогает убедиться, что байткод не подделывает указатели, не нарушает ограничения доступа, или
доступ к объектам, используя информацию неправильного типа.
Процесс проверки, совместно с функциями безопасности, встроенные в
язык через компилятор, помогает установить базовый набор гарантий
безопасности.

Верификация байт-кода
Процесс верификации состоит из четырех шагов.
Шаг 1. Выполняется при загрузке класса. При этом Java VM проверяет
базовый формат файла класса - "магическое число" и номер версии,
соответствие размера файла суммарному размеру его составляющих,
формальное соответствие отдельных структур спецификациям.
Шаг 2. Выполняется при связывании, он включает в себя верификацию
без анализа байт-кодов. На этом шаге проверяется:

•

Отсутствие нарушений в использовании классов и методов,
объявленных с модификатором final
• Наличие у каждого класса (кроме класса Object) суперкласса
• Соответствие спецификациям содержимого пула констант
• Правильность имен классов и интерфейсов и дескрипторов всех
полей и методов, ссылающихся на пул констант

Верификация байт-кода
Проверки правильности элементов файла класса,
выполняемые в предыдущем шаге, - только
формальные, не семантические. Более подробные
проверки выполняются на следующих шагах.
Шаг 3. Также выполняется на этапе связывания.
На этом шаге верификатор проверяет массив байт-кодов
каждого метода. При этом анализируется поток данных,
обрабатывающийся
при
выполнении
метода.
Верификатор исходит из того, что в любой точке
программы, независимо от того, каким образом
управление попало на эту точку, должны соблюдаться
определенные ограничения целостности данных,
которые сводятся в основном к следующим:

Верификация байт-кода
•

Размер стека операндов неизменен и стек содержит операнды
одного типа
• Не выполняется доступ к локальным переменным неизвестного
типа
• Доступ к локальным переменным осуществляется только в
пределах массива локальных переменных
• Все обращения к пулу констант производятся к элементам
соответствующего типа
• Полям класса назначаются значения соответствующего типа
• Все команды байт-кода используются с операндами (в стеке или в
массиве локальных переменных) типа, соответствующего типу
команды
• Методы вызываются с правильными аргументами
• Команды перехода передают управление только внутри байт-кода
метода и передача управления всегда происходит только на
первый байт команды байт-кода

Верификация байт-кода
Шаг 4. Выполняется при первом вызове кода любого метода. Это
"виртуальный шаг", он выполняется не в виде отдельного шага проверки
всего байт-кода, а при выполнении каждой отдельной команды.
Для команды, которая ссылается на тип, при этом:

• Загружается определение типа (если оно еще не загружено)
• Проверяется, может ли текущий выполняемый метод ссылаться на этот
тип
• Выполняется инициализация класса (если он еще не инициализирован)
Для команды, которая вызывает метод или осуществляет доступ к
полю класса, при этом:
• Проверяется, существует ли поле или метод в данном классе
• Проверяется правильность дескриптора вызванного метода или поля
• Проверяется, имеет ли текущий выполняемый метод права доступа к
этому методу или полю

Верификация байт-кода

•
•
•
•
•

Аплеты являются наиболее критическими с точки зрения безопасности Javaпрограммами, поскольку аплет загружается из Internet, возможно, из
непроверенного источника. Естественно, недопустимым является предоставление
программе, пришедшей "неизвестно откуда" доступа к ресурсам локального
компьютера. Поэтому для аплетов введены весьма жесткие ограничения на
выполнение. Аплету запрещается:
Получать сведения о пользователе или его домашней директории
Определять свои системные переменные
Работать с файлами и директориями на локальном компьютере (читать, изменять,
создавать и т.д. и даже проверять существование и параметры файла)
Осуществлять доступ по сети к удаленному компьютеру, получать список сетевых
сеансов связи, которые устанавливает локальный компьютер с другими
компьютерами
Получать доступ к любому нестандартному пакету, определять классы, входящие в
локальный пакет

Верификация байт-кода
Рассмотрим
пример
программы
VerifierTest.java,
демонстрирующую изменение файла класса в ручную. В этой программе
вызывается метод fun() и выводится результат его выполнения. Она
может быть запущена из командной строки или в виде аплета. Метод
fun() выполняет сложение чисел 1 и 2, как показано ниже.
Static int fun()
{
int m;
int n;
m = 1;
n = 2;
int r = m + n;
return r;
}

Верификация байт-кода
import java.awt.*;
import java.applet.*;
/**
В этой прикладной рпограмме демонстрируется верификатор байт-кода
виртуальной машины java. Если воспользоваться шестнадцатиричным
редактором для видоизменения файла класса, то виртуальная машина
должна обнаружить злонамерное искажение файла класса
*/
public class VerifierTest extends Applet
{
public static void main(String[] args)
{
System.out.println("1 + 2 == " + fun());
}

Верификация байт-кода
/**
Функция вычисляющая сумму чисел 1 + 2
return Возвращает сумму 3, если код не нарушен
*/
public static int fun()
{
int m;
int n;
m = 1;
n = 2;
//Воспользоваться шестнадцатеричным редактором, чтобы //изменить значение
переменной m на 2 в файле класса
int r = m + n;
return r;
}
public void paint(Graphics g)
{
g.drawString("1 + 2 == " + fun(), 20, 20);
}
}

Верификация байт-кода
В
качестве
эксперимента
попробуйте
скомпилировать
приведенный ниже видоизмененный вариант метода fun()
Static int fun()
{
int m = 1;
int n;
m = 1;
m = 2;
int r = m + n;
return r;
}

В данном случае переменная n не инициализированна и может
иметь произвольное значение. Естественно, что компилятор
обнаружит эту ошибку и откажется компилировать программу.

Организация защиты на платформе Java.
Диспетчеры полномочий
• Модель защиты в версии JDK 1.0
• Модель защиты в версии JDK 1.2 и выше
• Файлы правил защиты. Применение
• Полномочия. Диспетчеры полномочий

Организация защиты на платформе Java
Основная цель мер безопасности в Java — обеспечить защиту Javaокружения от вредоносных программ. Для достижения этой цели в JDK
1.0 была предложена концепция "песочницы" (sandbox) — замкнутой
среды, в которой выполняются потенциально ненадежные программы.
Таковыми считались аплеты, поступившие по сети. Весь "родной" код (то
есть программы, располагающиеся на локальном компьютере) считался
абсолютно надежным и ему было доступно все, что доступно
виртуальной Java-машине.

Организация защиты на платформе Java
В число ограничений, налагаемых "песочницей", входит запрет на
доступ к локальной файловой системе, на сетевое взаимодействие со
всеми хостами, кроме источника аплета (хост, с которого аплет был
получен) и т.д. При таких ограничениях безопасность в общем и целом
обеспечивается, но возможности для работы у аплетов почти не остается.
Чтобы как-то справиться с этой проблемой, в JDK 1.1 ввели понятие
электронной подписи, которую ставит распространитель аплета. Javaмашина в соответствии со своей политикой безопасности делит
распространителей и, соответственно, их аплеты на две категории —
надежные и ненадежные (неподписанный аплет, естественно, считается
ненадежным).
Надежные аплеты были приравнены в правах к "родному" коду, в
результате чего модель безопасности эволюционировала к виду,
приведенному на следующем слайде.

Организация защиты на платформе Java

Организация защиты на платформе Java
Таким образом, в JDK 1.1 произошло скачкообразное
расширение прав аплетов. Это решило проблемы тех, кому прав
не хватало (достаточно было попасть в число надежных
распространителей), однако весьма грубое деление прав доступа
— все или (почти) ничего — делало оборону неэшелонированной
и, следовательно, уязвимой. Любая ошибка при определении
"свой/чужой" становилась фатальной.
В JDK 1.2 по существу произошло обобщение «песочницы».
Оформились три основных понятия:
• Источник программы
• Право и множество прав
• Политика безопасности

Организация защиты на платформе Java
Источник программы определяется парой (универсальный
локатор ресурсов — URL, распространители программы — те, кто
подписал ее). URL может указывать на файл в локальной
файловой системе или же на ресурс удаленной системы.
Право — это абстрактное понятие, за которым, как обычно в Java,
стоят классы и объекты. В большинстве случаев право
определяется двумя цепочками символов — именем ресурса и
действием.
Например, в качестве ресурса может выступать файл, а в
качестве действия — чтение. Важнейшем методом "правовых"
объектов является implies(). Он проверяет, что одно право
(запрашиваемое) следует из другого (имеющегося).

Организация защиты на платформе Java
Политика безопасности задает соответствие между источником и
правами поступивших из него программ. Вообще говоря, в JDK 1.2
"родные" программы не имеют каких-либо привилегий в плане
безопасности и политика по отношению к ним может быть любой.
Формально можно считать, что каждому источнику соответствует
своя "песочница". Разработчики механизмов безопасности в JDK 1.2
ввели (точнее, использовали) понятие домена защиты, понимая под ним
совокупность источника программ и ассоциированных прав доступа. Но
содержательных операций над доменами не определено, так что с нашей
точки зрения данное понятие в JDK 1.2 является избыточным, а
проведение аналогий между доменами и "песочницей" —
неправомерным. По сути мы имеем традиционный для современных
операционных систем и систем управления базами данных механизм
прав доступа с особенностями

Организация защиты на платформе Java
•

Субъектом доступа является не пользователь, а
источник программы. Впрочем, формально можно
считать, что во время исполнения программы ее
источник становится пользователем

•

Нет понятия владельца ресурса, который (владелец)
мог бы менять права; последние задаются
исключительно политикой безопасности. Впрочем,
формально можно считать, что владельцем всего
является тот, кто формирует политику

•

Механизмы безопасности снабжены объектной
оберткой

Организация защиты на платформе Java
Начиная с версии Java SE 1.2 на платформе Java
предоставляется намного более гибкий механизм защиты.
Правила защиты преобразуют источники кода в наборы
полномочий, как показано на рисунке

Организация защиты на платформе Java

Организация защиты на платформе Java

Файлы правил защиты. Применение
Диспетчер правил защиты считывает содержимое файлов
правил защиты, т.е. инструкции для преобразования источников
кода в полномочия. Ниже приведен пример типичного файла
правил защиты. Этот файл предоставляет полномочия на чтение
и запись файлов в каталог /tmp любому коду, загруженному по
адресу http://www.zss.sut.ru/classes

Grant
codeBase
“http://www.zss.sut.ru/classes”
{
permission java.io.FilePermission
“/tmp/*”, “read, write”;
};

Файлы правил защиты. Применение
Устанавливаться файлы правил защиты могут только
стандартных местах. По умолчанию такими местами являются:
•
•

в

Файл java.policy в основном каталоги платформы Java
Файл .java.policy в рабочем каталоге пользователя (обратите
внимание на точку, стоящую в начале его имени)
Если требуется, чтобы правила защиты хранились вне файловой
системы, можно сначала реализовать подкласс, производный от
класса Policy и собирающий сведения обо всех полномочиях, а
затем изменить строку в конфигурационном файле java.security
следующим образом:

policy.provider = sun.security.provider.PolicyFile

Файлы правил защиты. Применение
Не имеет смысла постоянно вносить изменения в стандартные
файлы защиты, поэтому рекомендуется разместить сначала все
полномочия в отдельном файле, например MyApp.policy, а затем указать
явным образом имя этого файла для каждой прикладной программы. А
применить правила защиты можно двумя способами. Во-первых,
установить свойства системы в главном методе прикладной программы:
System.setProperty(“java.security.policy”,
“MyApp.policy”);

И во-вторых, запустить виртуальную машину, введя следующую
команду:
java –Djava.security.policy=MyApp.policy MyApp

В приведенных примерах файл MyApp.policy добавляется к
остальным действующим правилам защиты.

Файлы правил защиты. Применение
Диспетчер защиты в прикладных программах на Java по
умолчанию не устанавливается. Это означает, что до тех пор, пока он не
будет установлен, увидеть действия файлов правил защиты не удастся. А
установить диспетчер защиты можно двумя способами. Во-первых,
добавить в тело метода main() следующую строку кода:
System.setSecurityManager (new SecurityManager());

И во-вторых, указать при запуске виртуальной машины параметр
командой строки –Djava.security.manager, как показано ниже
Java –Djava.security.manager –
Djava.security.policy=MyApp.policy MyApp

Полномочия
Под полномочиями (иначе – правами доступа или
привилегиями) подразумеваются любые свойства, которые
проверяются диспетчером защиты. На платформе Java
поддерживается целый ряд представляющих полномочия
классов, каждый из которых инкапсулирует подробности
конкретных полномочий.
В качестве примера ниже приведено получение
экземпляра класса FilePermission, дающего разрешение на
чтение и запись люого файла в каталоге /tmp.
FilePermission p = new FilePermission

Полномочия

Полномочия
Итак, в файле правил защиты содержится последовательность записей
grant, каждая из которых имеет следующий вид:
grant источник_кода
{
полномочие_1;
полномочие_2;
…
}

Сведения о кодовой базе указываеются следующим образом:

codeBase “url”

В качестве разделителя файлов в URL кодовой базы должны всегда
использоваться знаки косой черты, даже если речь идет об URL со ссылками на
файлы в операционной системе Windows, как в следующем примере:
Grant codeBase “file:C:/myapps/classes/” {….};

Полномочия
Полномочия задаются в следующей синтаксической форме:
Permission ИмяКласса ИмяЦелевогоОбъекта, СписокДействий;

Вместо ИмяКласса указывается полностью уточненное имя
класса, предоставляющего конкретные полномочия (например,
java.io.FilePermission), а вместо ИмяЦелевогоОбъекта –
конкретный
целевой
объект,
на
который
должно
распространяться действие указываемых полномочий. И,
наконец, вместо параметра СписокДействий указывается
перечень охватываемых данным полномочием допустимых
действий, разделяемых запятой. В таблице перечислены
некоторые наиболее употребительные классы полномочий и
охватываемые ими действия.

Полномочия

Полномочия

Полномочия

Полномочия
вид:

Целевые объекты прав доступа к файлам могут иметь следующий

Файл
Каталог/
Каталог/*
*
Каталог/<<ALL FILES>>

Файл
Каталог

Все файлы данного каталога
Все файлы из текущего каталога
Все файлы из данного каталога и всех его подкаталогов
Все файлы из текущего каталога и всех его подкаталогов
Все файлы из файловой системы

Например, доступ разрешается ко всем файлам в
каталоге /myapp и любом из его подкаталогов.

permission java.io.FilePermission “/myapp/-”,
“read,write,delete”;

Доступ через сокет:

Permission java.net.SocketPermission “*.zss.sut.ru:8000-8999”,
“connect”;

Полномочия
Создание собственных классов полномочий, на
которые пользователи могут ссылаться в файлах правил
защиты. Для реализации классов полномочий следует
расширить
класс
Permission
и
реализовать
перечисленные методы:

•

Конструктор с двумя строковыми параметрами для
указания объекта и списка действий
• Метод String getActions()
• Метод boolean equals()
• Метод int hashCode()
• Метод boolean implies (Permission other)

Полномочия
Последний метод самый важный. Для полномочий предусмотрен
определенный порядок, в соответствии с которым наиболее общие
полномочия предполагают использование специальных прав доступа.
Например, приведенное ниже право доступа к файлу разрешает чтение и
запись любого файла из каталога /tmp и любых его подкаталогов.
p1 = new FilePermission (“/tmp/-”, “read, write”);

Это общее правило предполагает наличие других, специальных
прав доступа
Иными словами, право доступа к файлу p1 предполагает наличие
другого права доступа p2, если выполняются два условия:

• Набор целевых файлов в p1 содержит набор целевых файлов в p2
• Набор действий в p1 содержит набор действий в p2

Полномочия
Полномочия типа AllPermission предполагают все права доступа.
При определении собственных классов полномочий необходимо
определить предполагаемые права доступа. Например, для определения
прав доступа пользователя Tommy к телевизору под управлением
технологии Java в некотором промежутке времени можно определить
следующий класс TVPermission:
New TVPermission (“Tommy: 2-12: 1900-2200”, “watch, record”);

Этот класс разрешает пользователю Tommy смотреть и записывать
телевизионные передачи на каналах 2-12 в период с 19:00 до 22:00. Для
применения приведенного ниже специального права доступа придется
реализовать метод implies().
New TVPermission (“Tommy:4:2000-2100”, “watch”);

Полномочия
Демонстрация реализации новых полномочий для контроля над
текстом, вставляемым в текстовую область, на примере конкретной
программы.
В обязанности программы входит предотвращение попыток ввода в
текстовую область всевозможных «непристойных слов».
В исходном коде показано, каким образом действует класс
WordChekPermission. Данный класс конструирует полномочия на проверку
непристойных
слов, вроде sex, drugs и С++, но не Rock-n-roll.
А исходный код класса PermissionTest демонстрирует применение
специальных полномочий типа WordChekPermission.

Полномочия
WordCheckPermi
ssion()
getActions()
equals()
hashCode()
implies()
badWordSet()

import java.security.*;
import java.util.*;
//Разрешение , который проверяет наличие плохих
слов .
public class WordCheckPermission extends
Permission
{
public WordCheckPermission(String target, String
anAction)
{
super(target);
action = anAction;
}
public String getActions() { return action; }

Полномочия
WordCheckPermi
ssion()
getActions()
equals()
hashCode()
implies()
badWordSet()

public boolean equals(Object other)
{
if (other == null) return false;
if (!getClass().equals(other.getClass()))
return false;
WordCheckPermission b =
(WordCheckPermission)other;
if (!action.equals(b.action)) return false;
if (action.equals("insert"))
return getName().equals(b.getName());
else if (action.equals("avoid"))
return
badWordSet().equals(b.badWordSet());
else return false;
}
public int hashCode()
{
return getName().hashCode() +
action.hashCode();}

Полномочия
WordCheckPermi
ssion()
getActions()
equals()
hashCode()
implies()
badWordSet()

public boolean implies(Permission other)
{
if (!(other instanceof WordCheckPermission))
return false;
WordCheckPermission b =
(WordCheckPermission)other;
if (action.equals("insert"))
{
return b.action.equals("insert") &&
getName().indexOf(b.getName()) >= 0;
}
else if (action.equals("avoid"))
{
if (b.action.equals("avoid"))
return
b.badWordSet().containsAll(badWordSet());
else if (b.action.equals("insert"))
{

Полномочия
WordCheckPermi
ssion()
getActions()
equals()
hashCode()
implies()
badWordSet()

Iterator iter = badWordSet().iterator();
while (iter.hasNext())
{
String badWord =
(String)iter.next();
if (b.getName().indexOf(badWord) >= 0)
return false;
}
return true;
}
else return false;
}
else return false;
}

Полномочия
WordCheckPermi
ssion()
getActions()
equals()
hashCode()
implies()
badWordSet()

public Set badWordSet()
{
StringTokenizer tokenizer
= new StringTokenizer(getName(), ",");
Set set = new HashSet();
while (tokenizer.hasMoreTokens())
set.add(tokenizer.nextToken());
return set;
}
private String action;
}

Полномочия
PermissionTest.cl
ass
PermissionTestFr
ame.class
insertWords()
WordCheckTextA
rea.class

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.security.*;
import java.util.*;
import javax.swing.*;
// Этот класс демонстрирует пользовательский
WordCheckPermission
public class PermissionTest
{
public static void main(String[] args)
{
System.setSecurityManager(new
SecurityManager());
JFrame frame = new PermissionTestFrame();
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOS
E);
frame.show();
}}

Полномочия
PermissionTest.cl
ass
PermissionTestFr
ame.class
insertWords()
WordCheckTextA
rea.class

//Этот кадр содержит текстовое поле для вставки
слова в
текстовая область, которая защищена от
"плохих слов" .
class PermissionTestFrame extends JFrame
{
public PermissionTestFrame()
{
setTitle("PermissionTest");
setSize(WIDTH, HEIGHT);
textField = new JTextField(20);
JPanel panel = new JPanel();
panel.add(textField);
JButton openButton = new JButton("Insert");
panel.add(openButton);
openButton.addActionListener(new
ActionListener()
{

Полномочия
PermissionTest.cl
ass
PermissionTestFr
ame.class

public void actionPerformed(ActionEvent event)
{
insertWords(textField.getText());
}
});
Container contentPane = getContentPane();
contentPane.add(panel, BorderLayout.NORTH);

insertWords()

textArea = new WordCheckTextArea();
contentPane.add(new JScrollPane(textArea),
BorderLayout.CENTER);

WordCheckTextA
rea.class
}

Полномочия
PermissionTest.cl
ass
PermissionTestFr
ame.class
insertWords()
WordCheckTextA
rea.class

//Пытается вставить слова в текстовую область .
Отображает диалоговое окно, если попытка оказалась
неудачной.
public void insertWords(String words)
{
try
{
textArea.append(words + "\n");
}
catch (SecurityException e)
{
JOptionPane.showMessageDialog(this,
"I am sorry, but I cannot do that.");
}
}
private JTextField textField;
private WordCheckTextArea textArea;
private static final int WIDTH = 400;
private static final int HEIGHT = 300;}

Полномочия
PermissionTest.cl
ass
PermissionTestFr
ame.class
insertWords()
WordCheckTextA
rea.class

//Текстовая область,чей метод Append делает
проверку безопасности чтобы увидеть, что плохих
слов не добавляются.
class WordCheckTextArea extends JTextArea
{
public void append(String text)
{
WordCheckPermission p
= new WordCheckPermission(text, "insert");
SecurityManager manager =
System.getSecurityManager();
if (manager != null)
manager.checkPermission(p);
super.append(text);
}
}

Полномочия
Java.security.Permissin 1.2
Permission (String name)
Создает полномочия с указанным именем целевого объекта
String getName()
Возвращает имя целевого объекта для данных полномочий
Boolean implies (Permission other)
Проверяет, предполагают ли данные полномочия другие
полномочия. Это имеет место в том случае, если в других
полномочиях
описывается
более
конкретное
условие,
вытекающее из условия, указанного в данных полномочиях.

Аутентификация пользователей
• Аутентификация пользователей.
• Встроенные средства аутентификации
пользователей
• Библиотека java.security.auth, классы и методы.
• Примеры кода.
• Цифровая подпись.
• Алгоритмы SHA-1, MD5

Аутентификация пользователей
Аутентификация
процесс
проверки
принадлежности субъекту прав доступа к
информационным ресурсам системы или вебсайта в соответствии с предъявленным им
идентификатором.

Встроенные средства аутентификации
пользователей
Начиная с версии Java SE 1.4 в состав платформы Java
входит JAAS (Java Authentication and Authorization Service - служба
аутентификации и авторизации Java ).
Слово ”Authentication” B названии этой службы указывает
на возможность опознавания пользователей программ, а слово
”Authorization” - нa возможность проверки их полномочии.
Служба JAAS, по существу, представляет собой
встраиваемый прикладной интерфейс АРI, отделяющий
прикладные программы на Java от конкретной технологии,
применяемой для реализации средств аутентификации. Помимо
прочего, эта служба поддерживает механизмы регистрации B
UNIX и NT, механизм аутентификации Kerberos и механизмы
аутентификации по сертификатам.

Встроенные средства аутентификации
пользователей
После аутентификации за пользователем может быть
закреплен определенный набор полномочий. Ниже приведен
пример, B котором пользователю harry предоставляется особый
ряд полномочий, которых нет ни у кого из других пользователей.
grant principal com.sun.security.auth.UnixPrincipal “harry”
{
permission java.util.PropertyPermission "user.*", "read";
..
};

В данном пример класс com.sun.security.auth.UniXPrincipal
выполняет проверку имени запускающего данную программу
пользователя UNIX. Метод getName() из этого класса возвращает
имя пользователя, зарегистрированное в UNIX, которое затем
сравнивается на равенство с именем harry.

Встроенные средства аутентификации
пользователей
Для того чтобы предоставить диспетчеру защиты
возможность проверить правильность предоставления таких
полномочий, служит класс LoginContext. Ниже приведена общая
структура кода регистрации.
try{
System.setSecurityManager(new SecurityManager());
LoginContext context = new LoginContext("Loginl");
//определяется в конфигурационном файле службы JAAS
context.login();
//получить аутентифицированный объект типа Subject
Subject subject = context.getSubject();
context.logout();}
// это исключение генерируется, если попытка регистрации
оказалась неудачной
catch (LoginException exception)
{
exception.printStackTrace();}

Правила Аутентификации
Правила регистрации состоят из ряда модулей, каждый
из которых обозначен как required, sufficient, requisite или
optional. Значение этих ключевых слов можно понять из
приведенного ниже описания алгоритма регистрации.
1.
Модули выполняются по очереди до тех пор, пока
выполнение модуля Sufficient нe завершится успешно, а
выполнение модуля requisite - нeyдачно, или же до тех пор,
пока не будет достигнут конец списка модулей.
2. Аутентификация проходит успешно в том случае, если
выполнение всех модулей required и requisite завершается
успешно, ни один из них вообще не выполняется или хотя бы
один из модулей sufficient или optional завершается успешно.

Правила Аутентификации
При регистрации выполняется аутентификация субъекта, который:
может иметь несколько принципалов. Каждый принципал просто
описывает какое-то свойство субъекта, например, имя пользователя,
идентификатор группы или роль. Как было показано ранее в операторе
grant, принципалы управляют правами доступа. Объект типа
com.sun.security.auth.UnixPrincipal
описывает
имя
пользователя,
зарегистрированное B UNIX, а объект типа UnixNumeric Group Principal
может выполнять проверку на принадлежность пользователя к группе B
UNIX. Оператор grant позволяет проверить наличие принципала с помощью
следующей синтаксической конструкции:
Grant КлассПринципала «ИмяПринципала»
Следовательно, в рассматриваемом здесь примере этот оператор
принимает следующий вид:
grant com.sun.security.auth.UnixPrincipal

“harry”

Примеры кода аутентификации
В рассматриваемом далее примере программы AuthTest (ее
исходный код приведен на следующих слайдах) демонстрируется, как
ограничивать права доступа определениях пользователей. Эта программа
аутентифицирует пользователя, а затем выполняет действие,
извлекающее системное свойство. Для того чтобы данный пример
программы оказался работоспособным, коды регистрации и действия
должны
находиться
в
двух
отдельных
JAR-файлах.
В ОС Windows нужно залить UnіхРгіпсіраі на NTUserPrincipal в
файлах AuthTest.policy и jaas.configUnix и использоватьть точку с запятой
для разделения JAR-файлов, как показано в приведенной ниже команде.
java -classpath login.jar;action.jar...

После этого программа AuthTest должна отобразить значение
свойства user.home. Но если зарегистрироваться под другим учетным
именем, то должно возникнуть исключение, поскольку у данного
пользователя больше не будет требуемых полномочий.

Примеры кода аутентификации
Одна из задач модуля регистрации состоит в заполнении множества
принципалов аутентифицируемого субъекта. Если в модуле регистрации
поддерживаются роли, он должен также вводить в это множество объекты типа
Principal, описывающие соответствующие роли. В библиотеке Java отсутствует
класс для этой задачи, поэтому мы создали собственный класс. Этот класс
сохраняет пары “описание-значение” типа role=admin. A его метод getName ()
возвращает их, что дает возможность вводить ролевые полномочия в файл
правил регистрации‚ как показано ниже. Данный модуль регистрации
предусматривает поиск имен, паролей и ролей пользователей в текстовом
файле, содержащем приблизительно такие строки:

harrylsecretladmin
carlIguessmelHR
При разработке реального модуля регистрации эти сведения следовало
бы хранить в какой-нибудь базе данных или каталоге. Исходный код
рассматриваемого здесь примера представлен в листинге на следующих
слайдах.

Примеры кода аутентификации
login
if
NameCallback
Password
Callback
Callbackhandle
r.handle
Return
CheckLogin()

public boolean login() throws LoginException
if (callbackhandler == null) throw
new LoginException("no handler");
new
LoginException
NameCallback nameCall = new
NameCallback("username:")
PasswordCallback passCall = new
PasswordCallback(”password: ", false);
try{
callbackHandler.handle(new Callback[] {
nameCall, passCall});
}
catch (UnsupportedCallbackException e){
LoginException e2 = new
LoginException("Unsupported callback");
e2.initCause(e);
throw e2;}

Примеры кода аутентификации
login
if
NameCallback
Password
Callback
Callbackhandle
r.handle
Return
CheckLogin()

new
LoginException
catch (IOException e){
LoginException e2 = new
LoginException("I/O exception in callback");
e2.initCause(e);
throw e2;}
Try {
return checkLogin(nameCall.getName(),
passCall.getPassword());}
catch (IOExceptlon ex){
LoginException ex2 = new
LoginException();
ex2.initCause(ex);
throw ex2;}}

Примеры кода аутентификации
checkLogin()
Scanner(paths())
Arrays.equals()
Get principals
Logout
abort
commit

@param username Имя пользователя
@param password Символьный массив, содержащий
пароль
@return Возвращает логическое значение true, если
данные достоверны
private boolean checkLogin(String username, char[]
password)
throws LoginException, IOBxception {
try (Scanner in = new Scanner(Paths.get("" +
options.get('pwfile"))))
}
while (in.hasNextLine()){
String[] inputs = in.nextLine().split('\\|”);
if (inputs[0].equals(username) &&
Arrays.equals(inputs[1].toCharArray(). password))
{
String role = inputs[2]:

Примеры кода аутентификации
checkLogin()
scanner(paths())
arrays.equals()
subject.getPrinci
pals()
logout()
abort()
commit

Set<Principal> principals =
ubject.getPrincipals();
principals.add(new SimplePrincipal("username”,
username));
principals.add(new SimplePrincipal("role”, role));
return true;}
}
return false;}}
public boolean logout(){
return true;
}
public boolean abort(){
return true;
}
public boolean commit{
return true;}}

Примеры кода аутентификации
//Демонстрация аутентификации пользователей через специальную //регистрацию и
последующее
выполнение
действия
типа
//SysPropAction
с
привилегиями
зарегистрированного пользователя
public class AuthTest{
public static void main(final Strinq[] args){
System.seeSecurityManager(new SecutityManager());
try{
LoginContext context = new LoginContext("Loqin1");
context.login();
System.out.println("Authentication successful.");
Subject subject = context.getSubject();
System.out.println("subject=" + subject);
PrivilegedAction<Strinq> action = new SysPropAction(“user.home“);
String result = Subject.doAsPrivileged(subject, action, null);
System.out.println(result);
context.loqout();}
catch (LoginException e){
e.printStackTrace();}}}

Примеры кода аутентификации
//Это действие осуществляет поиск системного свойства
public class SysPropAction implements PrivilegedAction <String>
{
private String propertyName;
//конструирует действие для поиска заданного свойства
@param propertyName Имя свойства (прим. “user.home”)
public SysPropAction (String propertyName){
this.propertyName = propertyName;
}
public String run(){
return System.qetProperty (PropertyName);
}
}

Служба JAAS и ролевая аутентификация
Предоставление собственною модуля регистрации бывает
полезным в случаях, когда учетные данные сохраняются в базе
данных. Даже если вас вполне устраивает стандартный модуль
регистрации‚ изучение процесса реализации специального
модуля поможет вам лучше разобраться с предназначением
параметров в конфигурационном файле службы JААS.
Реализация механизма ролевой аутентификации играет
важную роль в тех случаях, когда требуется управлять большим
количеством пользователей. Размещать имена всех допустимых
пользователей в файле правил регистрации непрактично. Вместо
этого лучше поступить таким образом, чтобы модуль регистрации
сопоставлял пользователей с ролями вроде "admin" или "HR" и
предоставлял им права, исходя из их ролей.

Служба JAAS и ролевая аутентификация
Метод initialize() получает в качестве параметров
следующее:
Аутентифицируемый
объект
типа
Subject.
Обработчик для извлечения учетных данных.
Отображение
sharedState,
которое
можно
использовать для обмена данными между модулями
регистрации.
Отображение options, которое содержит пары
"имя-значение", задаваемые при настройке модуля
регистрации.

Служба JAAS и ролевая аутентификация
Допустим, рассматриваемый здесь модуль регистрации
настраивается приведенным ниже образом. В таком случае этот модуль
будет извлекать из отображения ортions параметры настройки pwfile.
SimpleLoginModule required pwfile="password.txt”;

Сбором имени пользователя и пароля данный модуль регистрации
не занимается, поскольку эта задача поручена отдельному обработчику.
Такое разделение ответственности позволяет использовать один и тоже
же модуль, не особенно беспокоясь, откуда именно поступают учетные
данные: из диалогового окна ГПИ, командной строки консоли или
конфигурационною файла. Требующийся обработчик задается при
создании экземпляра класса LoginContext, как показано в приведенном
ниже примере.
LoginContext context = new LoginContext(”Loginl”,
new com.sun.security.auth.callback.DialogCallbackHandler());

Служба JAAS и ролевая аутентификация
Обработчик типа DialogCallbackHandler открывает простое
диалоговое окно ГПИ для запрашивания имени пользователя и пароля, а
обработчик
типа
com.sun.security.auth.callback.TextCallbackHandler
извлекает эти учетные данные с консоли.
Но в данном примере для получения имени пользователя и пароля
использует собственный ГПИ (скриншот ниже). Для этой цели создается
специальный обработчик, способный сохранять и возвращать учетные
данные, как показано в листинге на следующем слайде.

Служба JAAS и ролевая аутентификация
//Конструирует обработчик обратных вызовов
@param username Имя пользователя
@param password Символьный массив, содержащий пароль
public SimpleCallbackHandler(String username, char[] password){
this.username = username;
this.password = password;
}
public void handle(Callback[] callbacks){
for (Callback callback : callbacks){
if (callback instanceof NameCallback){
((NameCallback) callback).setName(username);
}
else if (callback instanceof PasswordCallback){
((PasswordCallback) callback).setPassword(password);
}
}
}
}

Служба JAAS и ролевая аутентификация
Этот обработчик состоит из единственного метода handle(),
который обрабатывает массив объектов типа Callback. Интерфейс
Callback реализуется рядом предопределенных классов вроде
NameCallback и PasswordCallback. При желании можно добавить к
ним собственный класс, например RetinaScanCallback. Исходный
код этого обработчика выглядит не очень изящно, поскольку
нуждается в анализе типа объектов обратного вызова, как
показано ниже.
public void handle(Callback[] callbacks){
for (Callback callback : callbacks){
if (callback instanceof NameCallback) ...
else if (callback instanceof PasswordCallback) ...
else ...
}
}

Классы в библиотеке javax.security.auth.callback
Класс

Описание

CallbackHandler

Handle (Callback[] callbacks)

NameCallback

NameCallback (String promt)
NameCallback (String promt, String
defaultName)
getName()
setName()
getPromt()
getDefaultName()
PasswordCallback(String promt, boolean
echoOn)
getPassword()
setPassword()
setPassword( char[] password)
getPromt
isEchoOn

PasswordCallback

Методы в библиотеке javax.security.auth.callback

Методы в библиотеке javax.security.auth.callback

Библиотека javax.security.auth.spi.LoginModule

Цифровая подпись
Свертка сообщения - это цифровой “отпечаток” блока данных.
Например, алгоритм безопасного хеширования SНА-1 (Secure Hash
Algorithm 81) уплотняет любой блок данных в последовательность из
160 бит (20 байт). По аналогии с отпечатками пальцев, считается, что
не существует двух одинаковых цифровых отпечатков по алгоритму
SHA-1. На самом деле это не так, поскольку алгоритм SНА-1
поддерживает только 2160 отпечатков. Следовательно, теоретически
они могут совпасть. Но число 2160 настолько велико, что вероятность
дублирования цифровых отпечатков очень мала.
Свертка сообщения обладает двумя важными свойствами:
1. Если изменяется один или несколько битов данных, то изменяется и
свертка сообщения.
2. Исходное сообщение нельзя изменить таким образом, чтобы
полученное поддельное сообщение имело такую же свертку, как у
исходного сообщения.

Цифровая подпись
Для вычисления сверток был разработан целый ряд алгоритмов. Двумя
наиболее известными из них являются: алгоритм SHA-l, разработанный
Национальным институтом стандартов и технологий (National Institute of Standards
and Technology - NIST), и алгоритм MD5, изобретенный Рональдом Райвестом (Ronald
Rivest) из Массачусетского технологического института (Massachusetts Institute of
Technologies - MIT).
Оба эти алгоритма способны шифровать фрагменты сообщений своим
оригинальным способом. Подробнее с ними можно ознакомиться, например, в
книге Cryptography and Network Security, 5th Edition Вильяма Столлингса (William
Stallings; издательство Prentice Hall, 2011 r.). Следует, однако, иметь в виду, что
недавно в обоих алгоритмах были обнаружены незначительные изъяны.
В настоящее время многие специалисты по шифрованию рекомендуют
избегать алгоритма MD5 и пользоваться алгоритмом SНА-1 до тех пор, пока не
появится какой-нибудь более надежный альтернативный вариант.

Цифровая подпись
В Java реализованы оба упомянутых выше алгоритма. Класс
MessageDigest представляет собой фабрику для создания объектов,
инкапсулирующих алгоритмы получения цифровых отпечатков. Класс содержит
статический
метод
getInstance(),
возвращающий
экземпляр
подкласса‚ производного от класса MessageDigest.
Поэтому класс MessageDigest может выступать в роли фабричного класса
или суперкласса для всех алгоритмов получения свертки сообщения. Получение
объекта для вычисления цифровых отпечатков по алгоритму SHA-l:
MessageDigest alg = MessageDigest.getInstance("SKA-1");

После создания объекта типа MessageDigest ему нужно передать все
байты сообщения, повторно вызывая метод update(). Содержимое файла
передается объекту alg, формирующему цифровой отпечаток.

InputStream in = . . .
int ch;
while ((ch = in.read()) != -1)
alg.update((byte) ch);

Получение хеша строки MD5
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
public class MD5Hash {
public static String getHash(String str) throws NoSuchAlgorithmException,
UnsupportedEncodingException{
MessageDigest m = MessageDigest.getInstance("MD5");
m.reset();
// передаем в MessageDigest байт-код строки
m.update(str.getBytes("utf-8"));
// получаем MD5-хеш строки без лидирующих нулей
String s2 = new BigInteger(1, m.digest()).toString(16);
StringBuilder sb = new StringBuilder(32);
for (int i = 0, count = 32 - s2.length(); i < count; i++) {
sb.append("0");
}
// возвращаем MD5-хеш
return sb.append(s2).toString();}}

Примеры кода
//В этой программе вычисляется свертка сообщения из файла
public class Digest
{
public static void main(String[] args) throws IOException,
GeneralSecurityException
{
String algname = args.length >= 2 ? args[1] : "SHA-1";
MessageDigest alg = MessageDigest.getInstance(algname);
byte[] input = Files.readAllBytes(Paths.get(args[0]));
byte[] hash - alg.digest(input);
String d = "";
for (int i = 0; i < hash.length; i++)
int v = hash[i] & 0xFF;
If (v<16) d += “0”;
d += Integer.toString(v,16).toUpperCase() + “ “;
}
System.out.println(d);
}}

Методы в библиотеке java.security.MessageDigest

Подписание сообщений
В предыдущем разделе было показано, как создавать свертку
сообщения, т.е. делать своего рода дактилоскопический отпечаток
исходного сообщения. Это означает, что при доставке сообщения
вместе с его цифровым отпечатком получатель сможет проверить, не
было ли оно подделано. Но если злоумышленнику удастся
перехватить как сообщение, так и его исходный отпечаток, то он
сможет легко изменить сообщение и переделать этот отпечаток так,
как ему нужно. Этот недостаток позволяют устранить цифровые
подписи.
Для того чтобы стал понятнее принцип действия цифровых
подписей, нужно сначала ввести некоторые понятия из области
шифрования открытым ключом. Основными в этой области являются
такие понятия, как открытый ключ и секретный ключ. Открытый ключ
сообщается всем, а секретный держится в строгом секрете.

Подписание сообщений
Алгоритм создания
подписи DSA

Сообщение

подпись
Секретный ключ DSA
Открытый ключ

Обмен сообщениями с использованием
цифровой подписи, открытых ключей и алгоритма
шифрования DSA

Алгоритм
верификации DSA

